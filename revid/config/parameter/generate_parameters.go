// +build ignore

/*
DESCRIPTION
  generate_parameters.go uses a template to generate implementations for the
  Parameter interface.

LICENSE
  Copyright (C) 2024 the Australian Ocean Lab (AusOcean). All Rights Reserved. 

  The Software and all intellectual property rights associated
  therewith, including but not limited to copyrights, trademarks,
  patents, and trade secrets, are and will remain the exclusive
  property of the Australian Ocean Lab (AusOcean).
*/


// Package parameter is autogenerated code for config parameters - DO NOT EDIT.
package parameter

import (
  "fmt"
  "strconv"
  "time"
  "strings"
)

type Parameter interface {
  Type() string
  Set(val string) error
}
`

const paramTemplate = `
type {{.N}} {{.BT}}
{{if and .E (not .M)}}
const (
  {{$name := .N}}
  {{- range $i, $e := .E}}{{- if eq $i 0}}{{$name}}{{$e}} {{$name}} = iota{{else}}{{$name}}{{$e}}{{end}}
  {{end -}}
)
{{end -}}

{{- if .E}}
func ({{.R}} *{{.N}}) Type() string { return "enum:{{range $i, $e := .E}}{{if eq $i 0}}{{$e}}{{else}},{{$e}}{{end}}{{end}}"}
{{else}}
func ({{.R}} *{{.N}}) Type() string { return "{{.BT}}"}
{{end -}}

func ({{.R}} *{{.N}}) Set(val string) error {
  {{- if eq .BT "string"}}
  *{{.R}} = {{.N}}(val)
  {{else if eq .BT "bool"}}
  switch val {
  case "true":
    *{{.R}} = true
  case "false":
    *{{.R}} = false
  default:
    return fmt.Errorf("not boolean value: %s",val)
  }
  {{else if eq .BT "int"}}
  _v, err := strconv.Atoi(val)
  if err != nil {
    return fmt.Errorf("could not convert set string to int: %w",err)
  }
  {{if ne .Min .Max}}
  if _v < {{.Min}} || _v > {{.Max}} {
    return fmt.Errorf("invalid value %v",_v)
  }
  {{end}}
  *{{.R}} = {{.N}}(_v)
  {{else if eq .BT "uint"}}
  _v, err := strconv.Atoi(val)
  if err != nil {
    return fmt.Errorf("could not convert set string to int: %w",err)
  }
  {{if ne .Min .Max}}
  if _v < {{.Min}} || _v > {{.Max}} {
    return fmt.Errorf("invalid value %v",_v)
  }
  {{end}}
  *{{.R}} = {{.N}}(_v)
  {{else if eq .BT "float64"}}
  _v, err := strconv.ParseFloat(val,64)
  if err != nil {
    return fmt.Errorf("could not convert set string to float: %w",err)
  }
  {{if ne .Min .Max}}
  if _v < {{.Min}} || _v > {{.Max}} {
    return fmt.Errorf("invalid value %v",_v)
  }
  {{end}}
  *{{.R}} = {{.N}}(_v)
  {{else if eq .BT "time.Duration"}}
  _v, err := strconv.Atoi(val)
  if err != nil {
    return fmt.Errorf("could not convert set string to int: %w",err)
  }
  *{{.R}} = {{.N}}(time.Duration(_v)*time.Second)
  {{else if .M}}
  vals := strings.Split(val, ",")
  *{{.R}} = make({{.BT}}, len(vals))

  for i, v := range vals {
  switch v {
  {{- $receiver := .R}}
    {{- $m := .M}}
    {{range .E}}case "{{ . }}":
      (*{{$receiver}})[i] = {{$m}}{{ . }}
    {{end -}}
    default:
      return fmt.Errorf("unrecognised {{.N}}: %s",val)
    }
  }
  {{else}}
  switch val {
  {{- $receiver := .R}}
  {{- $name := .N}}
  {{range .E}}case "{{ . }}":
    *{{$receiver}} = {{$name}}{{ . }}
  {{end -}}
  default:
    return fmt.Errorf("unrecognised {{.N}}: %s",val)
  }
  {{end -}}

  return nil
}
`

func main() {
	f, err := os.Create(fileName)
	if err != nil {
		panic(fmt.Sprintf("error creating %s file: %v", fileName, err))
	}
	defer f.Close()

	var buf bytes.Buffer

	_, err = buf.Write([]byte(fileHeader))
	if err != nil {
		panic(fmt.Sprintf("error writing header: %v", err))
	}

	param := template.Must(template.New("param").Parse(paramTemplate))

	for _, p := range params {
		// Use first letter of parameter name as receiver.
		p.R = strings.ToLower(p.N[:1])
		err = param.Execute(&buf, p)
		if err != nil {
			panic(fmt.Sprintf("error executing template: %v", err))
		}
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		f.Write(buf.Bytes()) // Useful to debug bad format.
		panic(fmt.Sprintf("error formatting: %v", err))
	}

	_, err = f.Write(b)
	if err != nil {
		panic(fmt.Sprintf("error writing %s file: %v", fileName, err))
	}
}
