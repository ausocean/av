/*
NAME
  rtp_test.go

DESCRIPTION
  See Readme.md

AUTHOR
  Saxon Nelson-Milton (saxon@ausocean.org)

LICENSE
  Copyright (C) 2024 the Australian Ocean Lab (AusOcean). All Rights Reserved. 

  The Software and all intellectual property rights associated
  therewith, including but not limited to copyrights, trademarks,
  patents, and trade secrets, are and will remain the exclusive
  property of the Australian Ocean Lab (AusOcean).
*/


package rtp

import (
	"reflect"
	"testing"
)

// TODO (saxon): add more tests
var rtpTests = []struct {
	num  int
	pkt  Packet
	want []byte
}{
	// No padding, no CSRC and no extension.
	{
		num: 1,
		pkt: Packet{
			Version:    2,
			CSRCCount:  0,
			PacketType: 6,
			Sync:       167,
			Timestamp:  160,
			SSRC:       10,
			Payload: []byte{
				0x00, 0x01, 0x07, 0xf0,
				0x56, 0x37, 0x0a, 0x0f,
			},
		},
		want: []byte{
			0x80, 0x06, 0x00, 0xa7,
			0x00, 0x00, 0x00, 0xa0,
			0x00, 0x00, 0x00, 0x0a,
			0x00, 0x01, 0x07, 0xf0,
			0x56, 0x37, 0x0a, 0x0f,
		},
	},
	// With padding.
	{
		num: 2,
		pkt: Packet{
			Version:     2,
			PaddingFlag: true,
			CSRCCount:   0,
			PacketType:  6,
			Sync:        167,
			Timestamp:   160,
			SSRC:        10,
			Payload: []byte{
				0x00, 0x01, 0x07, 0xf0,
				0x56, 0x37, 0x0a, 0x0f,
			},
			Padding: []byte{
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x0b,
			},
		},
		want: []byte{
			0xa0, 0x06, 0x00, 0xa7,
			0x00, 0x00, 0x00, 0xa0,
			0x00, 0x00, 0x00, 0x0a,
			0x00, 0x01, 0x07, 0xf0,
			0x56, 0x37, 0x0a, 0x0f,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0b,
		},
	},
	// With padding and CSRC.
	{
		num: 3,
		pkt: Packet{
			Version:     2,
			PaddingFlag: true,
			CSRCCount:   2,
			PacketType:  6,
			Sync:        167,
			Timestamp:   160,
			SSRC:        10,
			CSRC: [][4]byte{
				{0x01, 0x02, 0x03, 0x04},
				{0x05, 0x06, 0x07, 0x08},
			},
			Payload: []byte{
				0x00, 0x01, 0x07, 0xf0,
				0x56, 0x37, 0x0a, 0x0f,
			},
			Padding: []byte{
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x0b,
			},
		},
		want: []byte{
			0xa2, 0x06, 0x00, 0xa7,
			0x00, 0x00, 0x00, 0xa0,
			0x00, 0x00, 0x00, 0x0a,
			0x01, 0x02, 0x03, 0x04,
			0x05, 0x06, 0x07, 0x08,
			0x00, 0x01, 0x07, 0xf0,
			0x56, 0x37, 0x0a, 0x0f,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0b,
		},
	},
	// With padding, CSRC and extension.
	{
		num: 4,
		pkt: Packet{
			Version:     2,
			PaddingFlag: true,
			ExtHeadFlag: true,
			CSRCCount:   2,
			PacketType:  6,
			Sync:        167,
			Timestamp:   160,
			SSRC:        10,
			CSRC: [][4]byte{
				{0x01, 0x02, 0x03, 0x04},
				{0x05, 0x06, 0x07, 0x08},
			},
			Extension: ExtensionHeader{
				ID: 15,
				Header: [][4]byte{
					{0x01, 0x02, 0x03, 0x04},
					{0x05, 0x06, 0x07, 0x08},
				},
			},
			Payload: []byte{
				0x00, 0x01, 0x07, 0xf0,
				0x56, 0x37, 0x0a, 0x0f,
			},
			Padding: []byte{
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x0b,
			},
		},
		want: []byte{
			0xb2, 0x06, 0x00, 0xa7,
			0x00, 0x00, 0x00, 0xa0,
			0x00, 0x00, 0x00, 0x0a,
			0x01, 0x02, 0x03, 0x04,
			0x05, 0x06, 0x07, 0x08,
			0x00, 0x0f, 0x00, 0x02,
			0x01, 0x02, 0x03, 0x04,
			0x05, 0x06, 0x07, 0x08,
			0x00, 0x01, 0x07, 0xf0,
			0x56, 0x37, 0x0a, 0x0f,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0b,
		},
	},
}

func TestRtpPktToByteSlice(t *testing.T) {
	for _, test := range rtpTests {
		got := test.pkt.Bytes(nil)
		if !reflect.DeepEqual(got, test.want) {
			t.Errorf("unexpected error for test %v: \ngot :%v\n want:%v\n", test.num, got,
				test.want)
		}
	}
}
